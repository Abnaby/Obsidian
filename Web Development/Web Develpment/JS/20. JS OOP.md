## Object  
### Create Object 
```js
const car = {
    name: 'Ford', // Public 
    year: 2015,
    color: 'red',
    "price": 5000, 
    description: function () {
    return `${this.name} - ${this.year} - ${this.color}`;
    }
}
```
### Accessing Object Proprieties
Two ways 
1. Using Dot notation 
```js
console.log(car.name) ;        // Ford
console.log(car.description()) // Ford - 2015 - red
console.log(car.description)   // will print fucntion body 
console.log(car.'price');      // SyntaxError: Unexpected string
```
2. Using the Array Notation
	- objectName[keyName]
```js
console.log(car['name']) ; // Ford
console.log(car['price']) ; // 5000
```
### Properties
#### Adding New Properties
```js
car.NewProp = "Non";
console.log(car);  
// {name: 'Ford', year: 2015, color: 'red', NewProp: 'Non', description: ƒ}
```
#### Deleting Properties
```js
delete car.NewProp;
console.log(car.NewProp); // returns 'undefined'
```
#### Checking Properties
```js
console.log('NewProp' in car) // returns false
console.log('name' in car) // returns true
```
## Class
- the `this` keyword refers to any object created with the `Job` class.
#### Constructor 
1. Old Implementation 
```javascript
function User(id, username, salary) {
  this.i = id;
  this.u = username;
  this.s = salary + 1000;
}
let userOne = new User(100, "Elzero", 5000);
```
2. ES6 
```javascript
class User {
  constructor(id, username, salary) {
    this.i = id;
    this.u = username;
    this.s = salary + 1000;
  }
}
let userOne = new User(100, "Elzero", 5000);
```
#### Properties And Methods
```javascript
class User {
  constructor(id, username, salary) {
    // Properties
    this.i = id;
    this.u = username || "Unknown"; // if name is empty will put Unknown instead
    this.s = salary < 6000 ? salary + 500 : salary;
    this.msg = function () {
      return `Hello ${this.u} Your Salary Is ${this.s}`;
    };
  }
  // Methods
  writeMsg() {
    return `Hello ${this.u} Your Salary Is ${this.s}`;
  }
}
```
Usage 
```js 
let userTwo = new User(101, "", 6000);
console.log(userTwo.u); // Unknown
console.log(userTwo.s); // 6000
console.log(userTwo.msg); // Native Code
console.log(userTwo.writeMsg); // Native Code
console.log(userTwo.msg()); // Hello Unknown Your Salary Is 6000
console.log(userTwo.writeMsg()); // Hello Unknown Your Salary Is 6000
```
#### Properties 
##### Computed Properties
- depends on changing values
- It is a part of Class \[\[Prototype]]:Object
- Syntax 
```js
[variable](param)
{
// Scope
}
```
- For example, when creating a job listing API, you might want developers to be able to change the `applyThrough` function name to another word, such as `applyThroughLinkedIn` or `applyThroughIndeed`, depending on their platform. To use computed properties, you need to wrap the property name in square brackets:
```js
let applyThrough = "applyThroughIndeed";

class Job {
  constructor(role, salary, applicationLink, isRemote) {
    this.role = role;
    this.salary = salary;
    this.applicationLink = applicationLink;
    this.isRemote = isRemote;
  }
  [applyThrough]() {
    if (applyThrough === "applyThroughLinkedin") {
      return `Apply through Linkedin`;
    } else if (applyThrough === "applyThroughIndeed") {
      return `Apply through Indeed`;
    }
  }
}

// Can be called as 
job1.applyThroughIndeed(); // return 'Apply through Indeed'
```
##### Private Properties
- You can declare private properties inside a class by prefixing the variable with the ==`#`== sign.
```js
class Client {
  #client_unique_id = "";
  constructor(name, age, id) {
    this._name = name;
    this._age = age;
    this.#client_unique_id = id;
  }
}
```
- Output 
```js
let cl = new Client("Benjamin Adeleye", 30, "##34505833404494");
console.log(cl.name); // Benjamin
console.log(cl.#client_unique_id); 
// returns Uncaught SyntaxError: Private field '#client_unique_id' must be declared in an enclosing class
```
##### Static Properties
- By default static is a public prop for class not instance
- To track the number of clients in the database, you can use the `static` keyword:
```js
class Client{
  static clientCount = 0;
  constructor(name, age) {
    this._name = name;
    this._age = age;
    Client.clientCount++ ; // we can't use this because it is class spacfic 
  }
  static getClients() {
	return this.clientCount; 
  }
}
```
- Output
```js
let cl = new Client("Benjamin Adeleye", 30);
console.log(cl.getClients());
// would return undefined because static properties are bound to the class and not instances.
console.log(Client.getClients()); // return number of instance
```
#### Methods 
##### Getters and Setters
- Getters 
	- The `get` keyword helps you ensuring users' privacy
```js
let userType = "Eng"
class Client{
  constructor(name, age) {
    this._name = name;
    this._age = age;
  }
  get name() {
    if (userType === "Lawyer") {
      return this._name;
    } else {
      return "You are not authorized to view this information";
    }
  }
}
```
- Outputs 
```js
let c = new Client("Mo", 25);
console.log(c.name); // You are not authorized to view this information
userType = "Lawyer"
console.log(c.name); // Mo
```
- Setters
	- The `set` keyword is the opposite of the `get` keyword.
	- The `get` keyword is used to control who can access properties, while the `set` keyword controls who can change the value of properties.
```js
// In class 
set name(newName) {
    if (userType === "Lawyer") {
      this._name = newName;
    } else {
      console.log("You are not authorized to change this information");
    }
  }
```
- Output 
```js
let c = new Client("Mo", 25);
userType = "Lawyer"
client.name = "Adeleye Benjamin";
```
##### Private Methods
- Using ==`#`==
```js
   #fetchClientDocs(id) {
    return "Fetching client with id: " + id;
  }
```

## Class Inheritance 
- it Support DRY (Don't Repeat yourself.)
- Class inheritance allows you to create objects based on other objects.
creating a `Product` class
```js
// Parent Class
class Product {
  constructor(name, price, description, image) {
    this.name = name;
    this.price = price;
    this.description = description;
    this.image = image;
  }
  formatprice() {
    return `${this.price}$`;
  }
  addToCart() {
    cart.add(this);
  }
}
```
Then, create a subclass for each product type using the `extends` keyword:
```js
// Derived Class
class Book extends Product {
  constructor(name, price, description, image, weight, pages, author) {
    super(name, price, description, image);
    this.author = author;
    this.weight = weight;
    this.pages = pages;
  }
}
```
#### ==`Extend`== Keyword 
- The `extends` keyword is self-explanatory; 
- it is used to extend the capability of another class. In our case, we used it to create the `Book` class by extending the `Product` class.
#### ==`super`== Keyword 
- The `super` keyword eliminates the multiple declarations you would otherwise need to repeat for each new child class. 
- For example, the `super` function called in the above code replaced the following code:
```js
	this.name = name;
	this.price = price;
	this.description = description;
	this.image = image;
```
- Remember DRY? the reason for this is not to repeat the above code because it has been written inside the `Product` class.
- The `super` function can be omitted if the child class does not need a constructor:
```js
class Animal {
  constructor(name, species, color) {
    this.name = name;
    this.species = species;
    this.color = color;
  }
  makeSound() {
    console.log(`${this.name} makes a noise.`);
  }
}

class Bird extends Animal {
  fly() {
    console.log(`${this.name} flies.`);
  }
}
```
- Output 
```js
const bird = new Bird('Chloe', 'Parrot', 'Green'); 
console.log(`${bird.name} is a ${bird.color} ${bird.species}`);
```
## Class Encapsulation
  - Class Fields are Public By Default
  - Guards The Data Against Illegal Access.
  - Helps To Achieve The Target Without Revealing Its Complex Details.
  - Will Reduce Human Errors.
  - Make The App More Flexible And Manageable.
  - Simplifies The App.
  ```javascript
class User {
  // Private Property
  #e;
  constructor(id, username, eSalary) {
    this.i = id;
    this.u = username;
    this.#e = eSalary;
  }
  // Using old school 
  getSalary() {
    return parseInt(this.#e);
  }
  // Using js keywords
  get Salary(){
    return parseInt(this.#e);
  }
}
```
Output 
```js
let userOne = new User(100, "Elzero", "5000 Gneh");

console.log(userOne.u); // Elzero
console.log(userOne.getSalary()); // 5000
console.log(userOne.Salary); // 5000
```
## Class Polymorphism
```js
class Animal {  
    makeSound() {  
        console.log('Animal makes a sound');  
    }  
}  
class Dog extends Animal {  
	// overwrite makeSound
    makeSound() {  
        console.log('Dog barks');  
    }  
}  
  
let animal = new Animal();  
let dog = new Dog();  
  
animal.makeSound(); // Output: 'Animal makes a sound'  
dog.makeSound();    // Output: 'Dog barks'
```