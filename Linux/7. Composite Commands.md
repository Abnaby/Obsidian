## Commands Philosophy 
- Create small, portable, specialized program perform one task well.
- Make the program capable of receiving input from, and redirect output to other programs 
## Command Model 
![[Pasted image 20240909180248.png]]
## I/O Streams 

| Function | Stream Name | Stream Descriptor | Default Device |
| -------- | ----------- | ----------------- | -------------- |
| Input    | stdin       | 0                 | Keypoard       |
| Output   | stdout      | 1                 | Screen         |
| Error    | stderr      | 2                 | Screen         |
### Build Composite Commands through 
1. Sequential Commands
2. Conditional Commands
3. Command Loops
4. Input/Output Redirection 
5. Pipes
6. Command Argument Expansion
7. Command Argument Quoting 
#### Sequential Commands
##### Notes 
- The Seq Commands just run after each other
- They have **Independent Input & output**
##### Syntax
```bash
<first Command>; <second Command>; <third Command>; 
```
##### Usage
* When first command takes a long time for execution (ثباح ال بيت بيك) 
##### Examples 
```bash
echo "one"; sleep 10; echo "Two"
```

```bash
make; sudo make install 
```
#### Conditional Commands
##### Notes 
- Based on Conditions
- They have **Dependent Input & output**
##### Syntax
```bash
<first Command> && <second Command> && <third Command>; 
```
##### Usage & Examples
**Or**ing ("||")
- Second Command will only execute if the *First Returns Failure*
- Used in Error Handling
```bash
cat <fileName> || echo "File Not Found" 
# if <fileName? doesn't exist will echo File Not Found otherwise dispaly cat content
```
**AND**ing ("&&")
- Second Command will only execute if the *First Returns Success
- Continue as long as you successful.
```bash
mkdir dir1 && cd dir1
# Will excute "cd dir1" if "mkdir dir1" return success
```
#### Command Loops
##### Syntax
```bash
for <iterable> in <list>
 > do
 > <action>
 > done
```
##### Examples 
- Rename all \*.txt to \*.old   
```bash
for file in *.txt
 > do
 > mv -v $file $file.old
 > done
```

#### Input/Output/Error Redirection 
- The redirection could be directed to screen or Devices  
- Common Devices 
	- Defaults 
		- /dev/stdout --> standard output device(Screen)
		- /dev/stderr --> standard error device (Screen)
		- /dev/stdin --> standard input device (Keyboard)
	- /dev/null
		- is and output device 
		- for unwanted output
	- /dev/zero
		- is an input device 
		- infinite stream of zeros
	- /dev/random
		- is an input device 
		- generate random values, (It may block)
	- /dev/urandom
		- is an input device 
		- generate random values -not 100% random-, (It non blocking)
	- /dev/null
		- Is an output device 
		- Simulate a full file 
		- Is used for testing purpose.
##### Standard Output Redirection 
- Redirect Output to a file
- if file not exist will create a file.
- if file exist it will overwrite it(>) and append (>>).
###### Notes
1. Error Messages still go to the screen
2. '>' can be replaced by `1>` which means redirect Output Stream
	1. Default stream number is 1 because it is an Output stream
###### Syntax
```bash
<Command> > file 
# > make rediraction, and overwrite the file if exists
<Command> >> file 
# > make rediraction, and append to the file if exists
```
###### Example
```bash 
echo "Hello World!" # Display on screen
echo "Hello World!" > greeting.txt # Will create greeting.txt and put Hello World!
echo " A" >> greeting.txt # Will append greeting.txt and put Hello World! A
```
- Combine files into one file
```bash
cat file1 file2 > file.txt # merge file1 + file2 =into=> file.txt 
```
##### Error Redirection 
###### Notes
1. will use stream number2 "error" stream for redirection
2. the output stream still in the screen
###### Syntax
```bash
<Command> 2> file 
# > make rediraction, and overwrite the file if exists
<Command> 2>> file 
# > make rediraction, and append to the file if exists
```
##### Standard and Error Redirection 
###### Syntax  
```bash
# For Different Files 
<Command> > file 2> file2 
# > make rediraction, and overwrite the file if exists
<Command> >> file 2>> file 
# > make rediraction, and append to the file if exists

# For same File
<Command> > file 2>&1  #both to same file
<Command> >> file 2>>&1 #both to same file
# ===
<Command> &> file # All streams to the file
<Command> &>> file
```
##### Input Redirection
###### Syntax
```bash
<Command> < file # take input from the file
```
##### Example
1. Gen Number of lines in file (`wc` == word count)
```bash
wc -l < logFile.log 
```
2. Sort Alphabetically
```bash
sort <log-file >sorted-log-file 
# Will sort all log file in sorted-log-file 
```
3. Spell check 
```bash
spell <report.txt >error.log
# output of spell <report.txt will be in error.log
```
#### Pipes 
##### Notes
- In user space the processes can't provide data to each other we need the kernel to pass data
- Pipes be in kernel space that connect between two process 
- It is mechanism for communication for process (inter-process communication IPC)
- is a unidirectional mechanism (One way)
##### Syntax 
1. Unidirectional Pipes
```bash
<command-1> | <command-2>
```
- the output of `command-1` is input of `command-2`
- Each `command` runs in a sub-shell of the shell issue it (child shells)
	- shell of `command-1` -- output--> 
	- -- Input -->shell of `command-2` 
2. tee command
![[Pasted image 20240909190619.png]]
```bash
<command-1> | tree <list of Sinks> <stdout>
```
##### Examples
1. grep on Error in log files
```basj
cat log-file.log | grep "Error"
# Output Lines has Error word in log-file.log and will displayed in screen
```
2. Display Lines contains `compress` in `gzip`
```bash
man gzip | grep -i "compress" # -i for case insenstive 
```
3. Content of `name-list.txt` -- to --> sort it 
```bash
cat name-list.txt | sort # Will be displayed in screen
cat name-list.txt | sort > file.log # Will be in file.log

```
4. tee example 
```bash
make | tee make1.out.txt # result of make will be in make1.out.txt and will displayed in screen 
make | tee -a make1.out.txt # -a for append
```
5. date
```bash
date | tee file1 file2 file3 
# Result will be in file1 file2 file3 and stdout
```
6. `yes` commands
```bash
yes <string> | <command> # -- <string> --> command default y
yes | rm -r ~/project
```

#### Command Argument Expansion
##### Using wildcard expansion (*,?,...)
- Applies for **File and Directory names**
```bash
cp * ../project 
echo * # ===> ls
```
##### tilde (~)
```bash
echo ~ # echo home name
```
##### Parameter Expansion($ $varName or ${varName} )
```bash 
echo $PATH # echo content of PATH Var
echo ${PATH} 
```
##### Arithmetic Expansion($ (()) )
```bash
echo $((2+6))
```
##### Brace Expansion($ {} )
- Repeat for each one in {}
```bash
echo abc-{A,B,C}def
##output 
# abc-Adef abc-Bdef abc-Cdef

mkdir A{1..5}
# Dirs A1, A2, A3, A4, A5
```
#### Command Argument Quoting
- **Double Quotes**
	- Protect strings (Spaces, wildcards ,tilde, ..)
	- Deal with variables as variables 
```bash
echo "*" # output *
echo "ls" # output ls
echo "my Name is $MY_NAME" # output my Name is MOHAMED 
```
- **Single Quotes**
	- Protect strings (Spaces, wildcards ,tilde, ..)
	- Deal with variables as strings 
```bash
echo '*' # output *
echo 'ls' # output ls
echo 'my Name is $MY_NAME' # output my Name is $MY_NAME 
```
- **Back Quotes**
	- converted output string to command 
```bash
cd /lib/modules/`uname -r` # eq to --> 
cd /lib/modules/$(uname -r) # eq to --> 
cd /lib/modules/3.11.0.15-generic 
```